#!/bin/bash

set -e

# General defaults
SCRIPT_NAME="$(basename ${0})"
OUT=$(pwd)"/"
CREATE_PATH=0
INTERACT=1
BITS=2048
EXIT_CODE=0

# Certificate authority defaults
CA_KEY=""
CA=""
CA_ONLY=""
TRUST=""
SUBJ=""

# Signed certificate defaults
DAYS=365 # 1 year
C=""
S=""
L=""
O=""
OU=""
CN=""
SAN=""
EMAIL=""

# Safe exit
_safe_exit() {
    trap - INT TERM EXIT
    exit $@
}

# Help Screen
_help() {
cat <<EOF
${SCRIPT_NAME}
This script simplifies the creation of certificate authorities and self-signed TLS certificates using OpenSSL.


Usage:

${SCRIPT_NAME} [OPTIONS]
# Run with no arguments to be prompted for required values
${SCRIPT_NAME}
# Only create a certificate authority and trust the generated certificate
${SCRIPT_NAME} --ca-only --trust
# Generate a signed certificate using an existing certificate authority
${SCRIPT_NAME} --ca-key='/path/to/CA.key' --ca-cert='/path/to/CA.pem'
# Automate certificate generation
${SCRIPT_NAME} --no-interaction -c 'US' -s 'California' -l 'Los Angeles' -o 'Example Org' -u 'Example Unit' -n 'example.com' -a 'www.example.com'


General Options:

  -h|--help            Display this help and exit
  -p|--path            Path to output generated files
  --no-interaction     Disables interactive prompts for answers
  -d|--duration        Validity duration of the certificate (in days)
  -b|--bits            Key size in bits (default '2048')

Certificate Authority Options:

  --ca-key             Path to certificate authority key file
                       (Generates new CA if not set)
  --ca-cert            Path to certificate authority cert file
                       (Generates new CA if not set)
  --ca-only            Instructs script to generate a certificate authority, and not to generate a signed certificate
  -t|--trust           Flag to trust certificate authority
                       (Do not set for default 'false')

Certificate Subject Options:

  -c|--country         Country Name (2 letter code)
  -s|--state           State or Province Name (full name)
  -l|--locality        Locality Name (eg, city)
  -o|--organization    Organization Name (eg, company)
  -u|--unit            Organizational Unit Name (eg, section)
  -n|--common-name     Common Name (e.g. server FQDN or YOUR name)
  -a|--san             Comma-delimited list of subject alternative names
  -e|--email           Email Address
EOF
}

# Parse variables
_parse_vars() {
    while [ -n "$1" ]; do
        # Parse arguments without values
        if [[ " -h -t " =~ " $1 " ]]; then
            ARG="${1}"
            VALUE=""
            shift
        # Parse arguments with "="
        elif [ "${1:0:2}" == "--" -o "${1:2:1}" == "=" ]; then
            ARG=${1%%=*}
            VALUE=${1/$ARG=/}
            shift
        # Parse arguments separated by space
        else
            ARG="$1"
            VALUE="$2"
            shift 2
        fi

        # Map values
        case $ARG in
            -h|--help) _help; _safe_exit 0;;
            --ca-key) CA_KEY="$VALUE";;
            --ca-cert) CA="$VALUE";;
            --ca-only) CA_ONLY=1;;
            -t|--trust) TRUST=1;;
            -c|--country) C="$VALUE";;
            -s|--state) ST="$VALUE";;
            -l|--locality) L="$VALUE";;
            -o|--organization) O="$VALUE";;
            -u|--unit) OU="$VALUE";;
            -n|--common-name) CN="$VALUE"; HAS_CN=true;;
            -a|--san) SAN="$VALUE";;
            -e|--email) EMAIL="$VALUE";;
            --no-interaction) INTERACT=0;;
            -p|--path) OUT="$VALUE";;
            --path-create) CREATE_PATH=1;;
            -d|--duration) DAYS="$VALUE";;
            -b|--bits) BITS="$VALUE";;
            -v|--verbose) printf "Warn: -v|--verbose option is deprecated.\n";;
            *) printf "ERROR: unknown parameter '${ARG}'\n"; _help; _safe_exit 1;;
        esac
    done
}

# Prompt for required variables that were not provided
_check_vars() {
    # Certificate authority files
    if [ -n "$CA_KEY" -a -n "$CA" ]; then
        if [ ! -f "$CA_KEY" ]; then
            printf "The specified certificate authorify key file does not exist\n"
            _safe_exit 1
        fi

        if [ ! -f "$CA" ]; then
            printf "The specified certificate authorify file does not exist\n"
            _safe_exit 1
        fi
    fi

    # Country
    if [ -z "$C" -a $INTERACT -eq 1 ]; then
        printf "Country Name (2 letter code) [AU]: "
        read -r C
    fi

    # State
    if [ -z "$ST" -a $INTERACT -eq 1 ]; then
        printf "State or Province Name (full name) [Some-State]: "
        read -r ST
    fi

    # Locality
    if [ -z "$L" -a $INTERACT -eq 1 ]; then
        printf "Locality Name (eg, city) []: "
        read -r L
    fi

    # Organization
    if [ -z "$O" -a $INTERACT -eq 1 ]; then
        printf "Organization Name (eg, company) [Internet Widgits Pty Ltd]: "
        read -r O
    fi

    # Organizational Unit
    if [ -z "$OU" -a $INTERACT -eq 1 ]; then
        printf "Organizational Unit Name (eg, section) []: "
        read -r OU
    fi

    # Common Name
    if [ -z "$CN" ]; then
        printf "Common Name (e.g. server FQDN or YOUR name) []: "
        read -r CN
    fi

    # Subject Alternative Names
    if [ -z "$SAN" -a -z "$HAS_CN" -a $INTERACT -eq 1 ]; then
        printf "Subject Alternative Name(s) (e.g. subdomains) []: "
        read -r SAN
    fi

    # Build DNS
    i=0
    read -r -a URLS <<< "${CN} ${SAN//,/ }"
    SAN=""
    for u in "${URLS[@]}"; do
        if [ -n "$u" ]; then
            i=$((i+1))
            SAN="${SAN}DNS.${i} = ${u// /}"$'\n'
        fi
    done

    # Email Address
    if [ -z "$EMAIL" -a $INTERACT -eq 1 ]; then
        printf "Email Address []: "
        read -r EMAIL
    fi

    # Make sure output directory ends with a directory separator
    if [ "${OUT: -1}" != "/" ]; then
        OUT="${OUT}/"
    fi

    # Check if output directory exists
    if [ ! -d "$OUT" ]; then
        if [ $CREATE_PATH -eq 1 ]; then
            # Create path
            mkdir -p "$OUT" || printf "Could not create directory '${OUT}'\n" && _safe_exit 1
        else
            # Report non-existent path
            printf "The specified directory '${OUT}' does not exist\n"
            _safe_exit 1
        fi
    fi

    # Build subject
    if [ -n "$C" ]; then
        SUBJ="${SUBJ}/C=${C}"
    fi
    if [ -n "$ST" ]; then
        SUBJ="${SUBJ}/ST=${ST}"
    fi
    if [ -n "$L" ]; then
        SUBJ="${SUBJ}/L=${L}"
    fi
    if [ -n "$O" ]; then
        SUBJ="${SUBJ}/O=${O}"
    fi
    if [ -n "$OU" ]; then
        SUBJ="${SUBJ}/OU=${OU}"
    fi
    if [ -n "$CN" ]; then
        SUBJ="${SUBJ}/CN=${CN}"
    fi
    if [ -n "$EMAIL" ]; then
        SUBJ="${SUBJ}/emailAddress=${EMAIL}"
    fi
}

# Trust certificate authority
_add_trusted_cert() {
    if [ -z "$TRUST" ]; then
        return
    fi

    case "${OSTYPE:-undefined}" in
        # MacOS
        darwin*) sudo security add-trusted-cert -d -r trustRoot -k "/Library/Keychains/System.keychain" "$CA";;
        # TODO: Implement certificate trusting for other systems
        # linux*) ;;
        *) printf "Error: Unsupported OSTYPE '${OSTYPE:-undefined}'\n"; EXIT_CODE=1;;
    esac
}

# Build certificate authority
_build_ca() {
    # Only proceed if CA args are not provided
    if [ -n "$CA" -a -n "$CA_KEY" ]; then
        return
    fi

    printf "Building certificate authority\n"

    CA_KEY="${OUT}CA.key"
    CA="${OUT}CA.pem"

    # Use existing CA in current directory
    if [ -f "$CA_KEY" -a -f "$CA" ]; then
        return
    fi

    # Generate certificate authority files
    openssl genrsa -out "$CA_KEY" "$BITS"
    openssl req -new -nodes -x509 -sha256 \
        -subj "$SUBJ" \
        -days "$DAYS" \
        -key "$CA_KEY" \
        -out "$CA"

    # Trust certificate
    _add_trusted_cert
}

# Sign certificate
_build_cert() {
    # Do not proceed if only building CA
    if [ -n "$CA_ONLY" ]; then
        return
    fi

    FILE=${CN/\*\./}

    # Build 
    cat > "${OUT}${FILE}.ext" << EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
${SAN}
EOF

    # Generate key and certificate signing request
    openssl genrsa -out "${OUT}${FILE}.key" "$BITS"
    openssl req -new -nodes -sha256 \
        -subj "$SUBJ" \
        -newkey "rsa:${BITS}" \
        -key "${OUT}${FILE}.key" \
        -out "${OUT}${FILE}.csr"

    # Create a signed certificate
    openssl x509 -req -sha256 -CAcreateserial \
        -CA "$CA" \
        -CAkey "$CA_KEY" \
        -days "$DAYS" \
        -extfile "${OUT}${FILE}.ext" \
        -in "${OUT}${FILE}.csr" \
        -out "${OUT}${FILE}.crt"

    rm -f "${OUT}${FILE}.ext"
}

# Order of execution
_parse_vars "$@"
_check_vars
_build_ca
_build_cert

# Report success
_safe_exit $EXIT_CODE
